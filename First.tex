\documentclass{article}


\usepackage[russian]{babel}
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}

\title{Теор дз - 1}
\author{Рекут Н.А., Б05-203}

\begin{document}
\maketitle

\begin{enumerate}

\item Рассмотрим два итератора: первый будет перемещаться на два элемента за итерацию, второй -- на один. Будем хранить указатели на элементы, в которых в текущей момент находятся итераторы. Заметим, что если в списке присутствует цикл, то за некоторое конечное время указатели итераторов будут указывать на одну и ту же точку. Можно представить это как двух людей, идущих по кругу (циклу) с разной скоростью -- в концу концов они встретятся. Если же оба итератора дойдут до $NULL$ (конца списка), не встретившись, то цикл в списке отсутсвует.


\item Заметим, что если разрешено выделить лишь $O(1)$ доппамяти, то скопировать элементы двусвязного списка в массив мы не сможем $\Rightarrow T(n) = T(\frac{n}{2}) + \Theta(\frac{n}{2})$, где $\Theta(\frac{n}{2})$ времени занимает переход к элементу с "индексом" $\frac{n - 0}{2}$. Тогда из рекуррентного соотношения, записанного выше, получаем: $T(n) = \Theta(\frac{\frac{n}{2} \cdot (1 - (1/2)^{\log_{2}(n)})}{1 - 1/2}) = \Theta (n(1 - (1/2)^{\log_{2}(n)}))$. Заметим, что $(1/2)^{\log_{2}(n)}$ стремится к 0 при $n$ стремится к $\infty$. Посему $\Theta (n(1 - (1/2)^{\log_{2}(n)})) = \Theta (n)$

\item Будем хранить в стэке пары вида $(i, h_i)$, где $i$ -- индекс (номер) прямоугольника, $h_i$ -- его высота.

Также добавим в начало стэка прямоугольник $(0, -10)$, в конец -- $(N+1, 0)$. Они будут полезны для корректной обработки остальных прямоугольников. Действовать будем по следующему алгоритму:

Рассмотрим $i$-ый прямоугольник. 

\begin{enumerate}
    \item Если его высота $h_i \geq h_j$, где $h_j$ -- высота прямоугольника на вершине стека, то кладём пару вида $(i, h_i)$ на верх стека.
    
    \item Иначе будем выполнять операцию следующего рода:
    
    Извлекаем $j$-ый прямоугольник из стэка, считаем его площадь. Далее извлекаем прямоугольник из стэка перед $j$-ым, считаем площадь прямоугольника, который можно вписать в гистограмму состоящую из $j$-ого и $(j-1)$-ого прямоугольника. Сравниваем с предыдущей площадью. Аналогичные операции производим до того момента, пока $h_j > h_i$.
    
    В момент, когда на вершине стека окажется некоторый $t$-ый прямоугольник, причём $h_t < h_i$. Тогда заносим $i$-ый прямоугольник в стэк в виде следующей пары $(t+1, h_i)$.
\end{enumerate}

В результате получаем алгоритм, который будет работать за $O(N)$ (т.к. алгоритм не более одного раза рассматривает один и тот же столбик в гистограмме). Необходимо не более $O(N)$ памяти (т.к. в худшем случае мы храним стеке все столбики гистограммы).

\item Рассмотрим бинпоиск по ответу следующего вида на отрезке $[1, \frac{max (h_i)}{q}]$:

\begin{enumerate}
    \item У каждого гоблина отнимем $q \cdot t$ очков здоровья, где $t$ -- текущее число, рассматриваемое в бинпоиске. Далее не рассматриваем умерших после этой операции гоблинов.
    
    \item У нас осталось $(p - q) \cdot t$ очков ''персонального'' урона, которые можно распределить среди ещё живых гоблинов. За $O(k) \leq O(n)$, где $k$ -- количество оставшихся в живых гоблинов, можно понять, хватает ли нам $t$ ударов для уничтожния всех гоблинов.
    
    \item Если хватает, то $t$ -- новая правая граница бинпоиска. Иначе $t+1$ -- новая левая.
\end{enumerate}

Получаем, что весь алгоритм будет работать за $log_2 (\frac{max (h_i)}{q })\cdot n$

\item Создадим два массива: массив префиксных сумм $arrOfSums$ и массив, где будут храниться значения минимальных префиксных сумм на рассматриваемом отрезке $arrOfMins$. Т.е. $arrOfMins[i] = min(arrOfSums[0], ... , arrOfSums[i])$. Массивы $arrOfSums$ и $arrOfMins$ можно заполнить за линию. Алгоритм заполнения $arrOfSums$ очевиден, алгоритм заполнения $arrOfMins$ имеет следующий вид:
\begin{enumerate}
    \item $arrOfMins[0] = arrOfSums[0]$
    
    \item  $arrOfMins[i] = min (arrOfSums[i], arrOfMins[i-1])$
\end{enumerate}

Тогда поиск подотрезка с максимальной суммой для каждого $p$ принимает следующий вид: максимальная сумма равна $arrOfSums[p] - arrOfMins[p-1]$. Если же нам нужно найти левую границу такого подотрезка, то в $arrOfMins$ будем хранить пары вида (минимальная сумма на подотрезке, правый индекс подотрезка, на котором эта минимальная сумма достигается).

\item Действуем по следующему алгоритму:

\begin{enumerate}
    \item Добавляем к всему отрезку $b_i$ как константу
    
    \item Создаём вспомогательный массив s в котором будем хранить запросы.
    
    \item На запросы в этот массив пишем $s[l] += q$ и $s[r+1] -= q$
    
    \item Заводим массив res, где будем хранить ответ. Прочитав все запросы, проходим по массиву слева направо, храним текущую сумму $x$ на префиксе. Также храним переменную $sum$, в которой будет ответ для $res$.
    
    \item В цикле делаем следующее:
    
    $s+= s[i]$
    
    $sum += s$
    
    $res[i] = sum$
    
    \item Надо рассмотреть алгоритм для прибавления константы: прибавим $b_i$ на нужные отрезки для каждого запроса (прибавление константы на подотрезок в офлайне)
    
\end{enumerate}

Получаем время работы $O(n)$

\item 

\begin{enumerate}
    \item Рассмотрим случай, когда $a_1 = a_2 = ... = a_{k-1} = a_{k+1} = ... = a_N \neq a_k$. Учитывая, что $k$ может принимать любые целые значения на отрезке $[1, n]$, поиск $k$-ого элемента будет работать за $O(n) > O(log n)$ (т.к. для поиска $k$-ого элемента нам потребуется пройтись по всему массиву).
    
    \item Воспользуемся следующим алгоритмом:
    
    \begin{enumerate}
        \item При помощи бинарного поиска находим минимальный элемент в массиве (если $a_1 \geq a_N$). Пусть это будет элемент, равный $a$. Эта операция занимает $O(log (n))$.
        
        \item Далее за не более чем $m$ операций (элемент повторяется в массиве не более, чем $m$ раз) проходим от найденного в бинпоиске элемента до крайнего слева элемента, равного $a$. Это занимает $O(m)$.
        
        \item Весь алгоритм работает за $O(log(n) + m)$.
    \end{enumerate}
\end{enumerate}

\end{enumerate}

\end{document} 
